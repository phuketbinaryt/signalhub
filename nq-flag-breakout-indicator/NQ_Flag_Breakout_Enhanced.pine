//@version=6
indicator("NQ Flag Breakout Pro - Enhanced", overlay=true, max_bars_back=5000)

// ════════════════════════════════════════════════════════════════════════════════
// INPUTS
// ════════════════════════════════════════════════════════════════════════════════

// === TREND FILTER ===
group1 = "═══ TREND FILTER ═══"
fastEmaLen   = input.int(9,  "Fast EMA", minval=1, group=group1)
slowEmaLen   = input.int(21, "Slow EMA", minval=1, group=group1)
trendEmaLen  = input.int(50, "Trend EMA", minval=1, group=group1)
showEmas     = input.bool(true, "Show EMAs", group=group1)

// === IMPULSE LEG DETECTION ===
group2 = "═══ IMPULSE LEG ═══"
impulseLookback = input.int(10, "Impulse Lookback Bars", minval=3, group=group2)
impulseATRmult  = input.float(2.0, "Min Impulse Size (x ATR)", minval=0.5, step=0.1, group=group2)
impulseVolMult  = input.float(1.5, "Min Impulse Volume (x Avg)", minval=1.0, step=0.1, group=group2)
impulseVolLen   = input.int(20, "Volume Average Length", minval=5, group=group2)

// === FLAG CONSOLIDATION ===
group3 = "═══ FLAG PATTERN ═══"
minFlagBars    = input.int(4, "Min Flag Bars", minval=2, group=group3)
maxFlagBars    = input.int(20, "Max Flag Bars from Impulse", minval=4, group=group3)
maxFlagHeight  = input.float(0.5, "Max Flag Height (x Pole)", minval=0.1, step=0.05, tooltip="Flag shouldn't retrace more than 50% of impulse", group=group3)
maxFlagATR     = input.float(1.2, "Max Flag Tightness (x ATR)", minval=0.3, step=0.1, group=group3)
flagVolReduce  = input.float(0.8, "Flag Volume Reduction (x Avg)", maxval=1.5, step=0.1, tooltip="Volume should contract during flag", group=group3)

// Flag slope validation (flags should slope against trend slightly)
checkFlagSlope = input.bool(true, "Validate Flag Slope", tooltip="Flag should consolidate with slight counter-trend bias", group=group3)
maxFlagSlope   = input.float(0.3, "Max Flag Slope (x Pole)", minval=0.0, maxval=0.8, step=0.05, tooltip="Slope relative to pole height", group=group3)

// === BREAKOUT CONFIRMATION ===
group4 = "═══ BREAKOUT ═══"
requireVolConf    = input.bool(true, "Require Volume Confirmation", group=group4)
breakoutVolMult   = input.float(1.3, "Breakout Volume (x Avg)", minval=1.0, step=0.1, group=group4)
confirmBars       = input.int(1, "Confirmation Bars", minval=0, maxval=3, tooltip="Wait N bars after breakout", group=group4)

// === RISK MANAGEMENT ===
group5 = "═══ RISK MANAGEMENT ═══"
stopLossType   = input.string("Flag Extreme", "Stop Loss Type", options=["Flag Extreme", "ATR Based", "Both (Tighter)"], group=group5)
stopATRmult    = input.float(1.5, "ATR Stop Multiplier", minval=0.5, step=0.1, group=group5)
tpMethod       = input.string("Measured Move", "Take Profit Method", options=["Measured Move", "ATR Multiple", "Risk-Reward Ratio"], group=group5)
tpATRmult      = input.float(3.0, "ATR TP Multiplier", minval=1.0, step=0.5, group=group5)
riskRewardRatio = input.float(2.0, "Risk-Reward Ratio", minval=1.0, step=0.5, group=group5)
measuredMoveMult = input.float(1.0, "Measured Move Multiplier", minval=0.5, step=0.1, tooltip="1.0 = 100% of pole, 1.5 = 150%", group=group5)

// === SESSION FILTER ===
group6 = "═══ SESSION FILTER ═══"
useSessionFilter = input.bool(true, "Enable Session Filter", group=group6)
sessionStart     = input.int(9, "Session Start Hour (EST)", minval=0, maxval=23, group=group6)
sessionEnd       = input.int(16, "Session End Hour (EST)", minval=0, maxval=23, group=group6)

// === DISPLAY ===
group7 = "═══ DISPLAY ═══"
showFlags      = input.bool(true, "Highlight Flag Zones", group=group7)
showImpulse    = input.bool(true, "Mark Impulse Legs", group=group7)
showLabels     = input.bool(true, "Show Entry/SL/TP Labels", group=group7)
showRR         = input.bool(true, "Show Risk-Reward Ratio", group=group7)
atrLen         = input.int(14, "ATR Length", minval=5, group=group7)

// ════════════════════════════════════════════════════════════════════════════════
// CORE CALCULATIONS
// ════════════════════════════════════════════════════════════════════════════════

// EMAs
fastEma  = ta.ema(close, fastEmaLen)
slowEma  = ta.ema(close, slowEmaLen)
trendEma = ta.ema(close, trendEmaLen)
atr      = ta.atr(atrLen)

// Volume
avgVol       = ta.sma(volume, impulseVolLen)
volAboveAvg  = volume > avgVol * impulseVolMult
volBelowAvg  = volume < avgVol * flagVolReduce
breakoutVol  = volume > avgVol * breakoutVolMult

// Trend filters
upTrend   = fastEma > slowEma and slowEma > trendEma and close > trendEma
downTrend = fastEma < slowEma and slowEma < trendEma and close < trendEma

// Session filter
sessionHour = hour(time, "America/New_York")
inSession = not useSessionFilter or (sessionHour >= sessionStart and sessionHour < sessionEnd)

// ════════════════════════════════════════════════════════════════════════════════
// IMPULSE LEG DETECTION (Enhanced with Volume)
// ════════════════════════════════════════════════════════════════════════════════

impulseUpNow =
     upTrend and
     close == ta.highest(close, impulseLookback) and
     (close - close[impulseLookback - 1]) > atr * impulseATRmult and
     volAboveAvg and
     inSession

impulseDnNow =
     downTrend and
     close == ta.lowest(close, impulseLookback) and
     (close[impulseLookback - 1] - close) > atr * impulseATRmult and
     volAboveAvg and
     inSession

// Track impulse price levels
var float impulseStartUp = na
var float impulseEndUp = na
var float impulseStartDn = na
var float impulseEndDn = na

if impulseUpNow
    impulseStartUp := close[impulseLookback - 1]
    impulseEndUp := close

if impulseDnNow
    impulseStartDn := close[impulseLookback - 1]
    impulseEndDn := close

// Bars since impulse
barsSinceImpulseUp = ta.barssince(impulseUpNow)
barsSinceImpulseDn = ta.barssince(impulseDnNow)
validBarsUp = barsSinceImpulseUp >= 0 ? barsSinceImpulseUp : 100000
validBarsDn = barsSinceImpulseDn >= 0 ? barsSinceImpulseDn : 100000

// ════════════════════════════════════════════════════════════════════════════════
// FLAG PATTERN DETECTION (Enhanced Quality Checks)
// ════════════════════════════════════════════════════════════════════════════════

// === BULL FLAG ===
consLenUp   = math.min(validBarsUp, maxFlagBars)

// Extract ta.* calls from ternary operators - ensure length is always >= 1
int safeLenUp = math.max(consLenUp, 1)
float flagHighUp_temp = ta.highest(high, safeLenUp)
float flagLowUp_temp  = ta.lowest(low, safeLenUp)
flagHighUp  = consLenUp >= 1 ? flagHighUp_temp : na
flagLowUp   = consLenUp >= 1 ? flagLowUp_temp : na
flagRangeUp = flagHighUp - flagLowUp

// Calculate flag start/end for slope
flagStartPriceUp = consLenUp >= minFlagBars ? close[consLenUp - 1] : na
flagEndPriceUp   = close
flagSlopeUp      = not na(flagStartPriceUp) ? (flagStartPriceUp - flagEndPriceUp) : 0 // Should be positive (downward slope) for bull flag

// Pole height
poleHeightUp = not na(impulseEndUp) and not na(impulseStartUp) ? impulseEndUp - impulseStartUp : na

// Flag retracement (shouldn't retrace too much)
flagRetracementUp = not na(poleHeightUp) and poleHeightUp > 0 ? (impulseEndUp - flagLowUp) / poleHeightUp : 0

// Volume check during flag
float avgVolInFlag_temp = ta.sma(volume, safeLenUp)
avgVolInFlag = consLenUp >= minFlagBars ? avgVolInFlag_temp : avgVol
flagVolOkUp  = avgVolInFlag < avgVol * flagVolReduce or not requireVolConf

// Slope validation
flagSlopeOkUp = true
if checkFlagSlope and not na(poleHeightUp) and poleHeightUp > 0
    slopeRatio = flagSlopeUp / poleHeightUp
    flagSlopeOkUp := slopeRatio > 0 and slopeRatio < maxFlagSlope // Slight downward slope

isBullFlagConsolidation =
     consLenUp >= minFlagBars and
     validBarsUp <= maxFlagBars and
     not na(flagRangeUp) and
     flagRangeUp < atr * maxFlagATR and
     flagRetracementUp < maxFlagHeight and
     flagVolOkUp and
     flagSlopeOkUp and
     upTrend

// === BEAR FLAG ===
consLenDn   = math.min(validBarsDn, maxFlagBars)

// Extract ta.* calls from ternary operators - ensure length is always >= 1
int safeLenDn = math.max(consLenDn, 1)
float flagHighDn_temp = ta.highest(high, safeLenDn)
float flagLowDn_temp  = ta.lowest(low, safeLenDn)
flagHighDn  = consLenDn >= 1 ? flagHighDn_temp : na
flagLowDn   = consLenDn >= 1 ? flagLowDn_temp : na
flagRangeDn = flagHighDn - flagLowDn

flagStartPriceDn = consLenDn >= minFlagBars ? close[consLenDn - 1] : na
flagEndPriceDn   = close
flagSlopeDn      = not na(flagStartPriceDn) ? (flagEndPriceDn - flagStartPriceDn) : 0 // Should be positive (upward slope) for bear flag

poleHeightDn = not na(impulseEndDn) and not na(impulseStartDn) ? impulseStartDn - impulseEndDn : na
flagRetracementDn = not na(poleHeightDn) and poleHeightDn > 0 ? (flagHighDn - impulseEndDn) / poleHeightDn : 0

float avgVolInFlagDn_temp = ta.sma(volume, safeLenDn)
avgVolInFlagDn = consLenDn >= minFlagBars ? avgVolInFlagDn_temp : avgVol
flagVolOkDn    = avgVolInFlagDn < avgVol * flagVolReduce or not requireVolConf

flagSlopeOkDn = true
if checkFlagSlope and not na(poleHeightDn) and poleHeightDn > 0
    slopeRatio = flagSlopeDn / poleHeightDn
    flagSlopeOkDn := slopeRatio > 0 and slopeRatio < maxFlagSlope

isBearFlagConsolidation =
     consLenDn >= minFlagBars and
     validBarsDn <= maxFlagBars and
     not na(flagRangeDn) and
     flagRangeDn < atr * maxFlagATR and
     flagRetracementDn < maxFlagHeight and
     flagVolOkDn and
     flagSlopeOkDn and
     downTrend

// ════════════════════════════════════════════════════════════════════════════════
// BREAKOUT DETECTION (Enhanced with Confirmation)
// ════════════════════════════════════════════════════════════════════════════════

wasBullFlag = isBullFlagConsolidation[confirmBars]
wasBearFlag = isBearFlagConsolidation[confirmBars]

bullBreakout = wasBullFlag and close > flagHighUp[confirmBars] and upTrend and inSession
bearBreakout = wasBearFlag and close < flagLowDn[confirmBars] and downTrend and inSession

// Volume confirmation
bullBreakoutVol = requireVolConf ? (bullBreakout and breakoutVol) : bullBreakout
bearBreakoutVol = requireVolConf ? (bearBreakout and breakoutVol) : bearBreakout

// Final signals
bullSignal = bullBreakoutVol
bearSignal = bearBreakoutVol

// ════════════════════════════════════════════════════════════════════════════════
// ENTRY / STOP LOSS / TAKE PROFIT CALCULATIONS
// ════════════════════════════════════════════════════════════════════════════════

// Helper function to calculate stop loss
calcBullStop(float flagLow, float currentClose, float currentAtr, string stopType, float atrMult) =>
    float stopFlag = not na(flagLow) ? flagLow : currentClose - (currentAtr * 2.0)
    float stopATR  = currentClose - (currentAtr * atrMult)
    float result = stopType == "Flag Extreme" ? stopFlag :
                   stopType == "ATR Based" ? stopATR :
                   math.max(stopFlag, stopATR)
    result

calcBearStop(float flagHigh, float currentClose, float currentAtr, string stopType, float atrMult) =>
    float stopFlag = not na(flagHigh) ? flagHigh : currentClose + (currentAtr * 2.0)
    float stopATR  = currentClose + (currentAtr * atrMult)
    float result = stopType == "Flag Extreme" ? stopFlag :
                   stopType == "ATR Based" ? stopATR :
                   math.min(stopFlag, stopATR)
    result

calcBullTP(float currentClose, float poleHeight, float currentAtr, string method, float mmMult, float atrMult, float rrRatio, float stopPrice) =>
    float pole = not na(poleHeight) and poleHeight > 0 ? poleHeight : currentAtr * 3.0
    float result = method == "Measured Move" ? currentClose + (pole * mmMult) :
                   method == "ATR Multiple" ? currentClose + (currentAtr * atrMult) :
                   currentClose + ((currentClose - stopPrice) * rrRatio)
    result

calcBearTP(float currentClose, float poleHeight, float currentAtr, string method, float mmMult, float atrMult, float rrRatio, float stopPrice) =>
    float pole = not na(poleHeight) and poleHeight > 0 ? poleHeight : currentAtr * 3.0
    float result = method == "Measured Move" ? currentClose - (pole * mmMult) :
                   method == "ATR Multiple" ? currentClose - (currentAtr * atrMult) :
                   currentClose - ((stopPrice - currentClose) * rrRatio)
    result

// ════════════════════════════════════════════════════════════════════════════════
// PLOTTING
// ════════════════════════════════════════════════════════════════════════════════

// === EMAs ===
plot(showEmas ? fastEma : na, "Fast EMA", color.new(color.aqua, 0), 2)
plot(showEmas ? slowEma : na, "Slow EMA", color.new(color.orange, 0), 2)
plot(showEmas ? trendEma : na, "Trend EMA", color.new(color.purple, 20), 2)

// === FLAG ZONES ===
bullFlagBg = showFlags and isBullFlagConsolidation
bearFlagBg = showFlags and isBearFlagConsolidation

bgcolor(bullFlagBg ? color.new(color.green, 92) : na, title="Bull Flag Zone")
bgcolor(bearFlagBg ? color.new(color.red, 92) : na, title="Bear Flag Zone")

// === IMPULSE MARKERS ===
plotchar(showImpulse and impulseUpNow, "Impulse Up", "▲", location.belowbar, color.new(color.lime, 30), size=size.tiny)
plotchar(showImpulse and impulseDnNow, "Impulse Down", "▼", location.abovebar, color.new(color.red, 30), size=size.tiny)

// === BREAKOUT SIGNALS ===
plotshape(bullSignal, "Bull Breakout", shape.triangleup, location.belowbar,
          color.new(color.green, 0), size=size.normal, text="LONG")
plotshape(bearSignal, "Bear Breakout", shape.triangledown, location.abovebar,
          color.new(color.red, 0), size=size.normal, text="SHORT")

// === ENTRY / SL / TP LABELS ===
// Limit labels to prevent overflow
var int labelCount = 0
var label[] entryLabels = array.new<label>(50)
var label[] slLabels = array.new<label>(50)
var label[] tpLabels = array.new<label>(50)

// Bear Signal Labels (simplified - just one combined label for now)
if bearSignal and labelCount < 50
    // Create single label with all info
    string labelText = "SHORT\nEntry: " + str.tostring(close, "#.##") +
                       "\nSL: " + str.tostring(close + atr * 2, "#.##") +
                       "\nTP: " + str.tostring(close - atr * 4, "#.##")

    var label myLabel = label.new(bar_index, high, labelText,
                                   color=color.new(color.red, 10),
                                   textcolor=color.white,
                                   size=size.normal,
                                   style=label.style_label_down)
    label.set_xy(myLabel, bar_index, high)
    label.set_text(myLabel, labelText)
    labelCount := labelCount + 1

// Bull Signal Labels (simplified)
if bullSignal and labelCount < 50
    // Create single label with all info
    string labelText = "LONG\nEntry: " + str.tostring(close, "#.##") +
                       "\nSL: " + str.tostring(close - atr * 2, "#.##") +
                       "\nTP: " + str.tostring(close + atr * 4, "#.##")

    var label myLabel = label.new(bar_index, low, labelText,
                                   color=color.new(color.green, 10),
                                   textcolor=color.white,
                                   size=size.normal,
                                   style=label.style_label_up)
    label.set_xy(myLabel, bar_index, low)
    label.set_text(myLabel, labelText)
    labelCount := labelCount + 1

// === PRICE LEVELS ===
float bullStopPlot = bullSignal ? calcBullStop(flagLowUp, close, atr, stopLossType, stopATRmult) : na
float bullTPPlot = bullSignal ? calcBullTP(close, poleHeightUp, atr, tpMethod, measuredMoveMult, tpATRmult, riskRewardRatio, bullStopPlot) : na

plot(bullSignal ? close : na, "Bull Entry", color.new(color.blue, 0), 2, plot.style_cross)
plot(bullStopPlot, "Bull SL", color.new(color.red, 0), 2, plot.style_cross)
plot(bullTPPlot, "Bull TP", color.new(color.green, 0), 2, plot.style_cross)

float bearStopPlot = bearSignal ? calcBearStop(flagHighDn, close, atr, stopLossType, stopATRmult) : na
float bearTPPlot = bearSignal ? calcBearTP(close, poleHeightDn, atr, tpMethod, measuredMoveMult, tpATRmult, riskRewardRatio, bearStopPlot) : na

plot(bearSignal ? close : na, "Bear Entry", color.new(color.blue, 0), 2, plot.style_cross)
plot(bearStopPlot, "Bear SL", color.new(color.red, 0), 2, plot.style_cross)
plot(bearTPPlot, "Bear TP", color.new(color.green, 0), 2, plot.style_cross)

// ════════════════════════════════════════════════════════════════════════════════
// ALERTS
// ════════════════════════════════════════════════════════════════════════════════

alertcondition(bullSignal, "Bull Flag Breakout",
               "Bull Flag Breakout - Entry: {{close}}, Check chart for SL/TP levels")
alertcondition(bearSignal, "Bear Flag Breakout",
               "Bear Flag Breakout - Entry: {{close}}, Check chart for SL/TP levels")

//@version=5
indicator("FVG Rejection Strategy (Buy & Sell)", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500)

// Input parameters
fvgMinSize = input.float(0.0, title="Minimum FVG Size (% of ATR)", minval=0, step=0.1) / 100
fvgMaxSize = input.float(0.0, title="Maximum FVG Size (% of ATR, 0=disabled)", minval=0, step=0.1) / 100
maxStopLossTicks = input.int(0, title="Max Stop Loss Distance (ticks, 0=disabled)", minval=0, step=10)
showFvgZones = input.bool(true, title="Show FVG Zone Boxes")
showRejectionLines = input.bool(true, title="Show Rejection High Lines")
maxCandlesToSignal = input.int(15, title="Max Candles to Wait for Signal", minval=5, maxval=50)
lineExtension = input.int(6, title="Rejection Line Extension (candles)", minval=1, maxval=20)
showDebug = input.bool(false, title="Show Debug Info")
showBuySignals = input.bool(true, title="Show Buy Signals")
showSellSignals = input.bool(true, title="Show Sell Signals")
showStopLoss = input.bool(true, title="Show Stop Loss Projection")
stopLossBuffer = input.int(3, title="Stop Loss Buffer (ticks)", minval=1, maxval=20)
swingLookback = input.int(10, title="Swing High/Low Lookback", minval=1, maxval=50)
maxStopLossProjections = input.int(10, title="Max Stop Loss Projections to Display", minval=1, maxval=50)
showTakeProfit = input.bool(true, title="Show Take Profit Projection")
riskRewardRatio = input.float(2.0, title="Risk:Reward Ratio", minval=0.5, maxval=10.0, step=0.5)
maxTakeProfitProjections = input.int(10, title="Max Take Profit Projections to Display", minval=1, maxval=50)
showEntryLine = input.bool(true, title="Show Entry Price Line")
maxEntryProjections = input.int(10, title="Max Entry Projections to Display", minval=1, maxval=50)
enableRiskManagement = input.bool(true, title="Enable Risk Management")
dollarValuePerTick = input.float(12.50, title="Dollar Value Per Tick", minval=0.01, step=0.01)
maxRiskPerTrade = input.float(100.0, title="Max Risk Per Trade ($)", minval=1.0, step=10.0)
maxSignalLabels = input.int(10, title="Max Signal Labels to Display", minval=1, maxval=50)
enableTimeFilter = input.bool(false, title="Enable Time Filter (New York)")
startHour = input.int(9, title="Start Hour (NY Time)", minval=0, maxval=23)
startMinute = input.int(30, title="Start Minute", minval=0, maxval=59)
endHour = input.int(16, title="End Hour (NY Time)", minval=0, maxval=23)
endMinute = input.int(0, title="End Minute", minval=0, maxval=59)
enableTrendFilter = input.bool(false, title="Enable Trend Filter")
trendFilterType = input.string("EMA", title="Trend Indicator Type", options=["EMA", "SMA"])
trendFilterLength = input.int(200, title="Trend Filter Length", minval=1, maxval=500)
trendFilterMode = input.string("With Trend", title="Trade Mode", options=["With Trend", "Against Trend", "Both"])
showTrendLine = input.bool(true, title="Show Trend Line")
showStatsTable = input.bool(true, title="Show Performance Stats Table")
statsTablePosition = input.string("Top Right", title="Stats Table Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"])
statsTimeframe = input.string("All Time", title="Stats Timeframe", options=["Current Session", "Current Week", "All Time"])
sessionStartHour = input.int(18, title="Session Start Hour (NY Time)", minval=0, maxval=23)
showSessionStats = input.bool(false, title="Show Session Breakdown (Asia/London/NY)")
formatForDiscord = input.bool(false, title="Format Alerts for Discord Webhook")
enableTPSLAlerts = input.bool(false, title="Enable Take Profit / Stop Loss Alerts")

// Session-Specific Settings
useSessionSettings = input.bool(false, title="Use Session-Specific Settings")

// Asia Session Settings (18:00-02:00 NY)
asiaEnabled = input.bool(true, title="Asia: Enable Session")
asiaStopLossBuffer = input.int(3, title="Asia: Stop Loss Buffer (ticks)", minval=1, maxval=20)
asiaSwingLookback = input.int(10, title="Asia: Swing Lookback", minval=1, maxval=50)
asiaRiskReward = input.float(2.0, title="Asia: Risk:Reward Ratio", minval=0.5, maxval=10.0, step=0.5)
asiaMaxRisk = input.float(100.0, title="Asia: Max Risk Per Trade ($)", minval=1.0, step=10.0)
asiaMaxCandles = input.int(15, title="Asia: Max Candles to Signal", minval=5, maxval=50)
asiaTimeFilterEnabled = input.bool(false, title="Asia: Enable Time Filter")
asiaStartHour = input.int(18, title="Asia: Start Hour (NY)", minval=0, maxval=23)
asiaEndHour = input.int(2, title="Asia: End Hour (NY)", minval=0, maxval=23)
asiaTrendFilterEnabled = input.bool(false, title="Asia: Enable Trend Filter")
asiaTrendFilterMode = input.string("Both", title="Asia: Trend Mode", options=["With Trend", "Against Trend", "Both"])

// London Session Settings (02:00-08:00 NY)
londonEnabled = input.bool(true, title="London: Enable Session")
londonStopLossBuffer = input.int(3, title="London: Stop Loss Buffer (ticks)", minval=1, maxval=20)
londonSwingLookback = input.int(10, title="London: Swing Lookback", minval=1, maxval=50)
londonRiskReward = input.float(2.0, title="London: Risk:Reward Ratio", minval=0.5, maxval=10.0, step=0.5)
londonMaxRisk = input.float(100.0, title="London: Max Risk Per Trade ($)", minval=1.0, step=10.0)
londonMaxCandles = input.int(15, title="London: Max Candles to Signal", minval=5, maxval=50)
londonTimeFilterEnabled = input.bool(false, title="London: Enable Time Filter")
londonStartHour = input.int(2, title="London: Start Hour (NY)", minval=0, maxval=23)
londonEndHour = input.int(8, title="London: End Hour (NY)", minval=0, maxval=23)
londonTrendFilterEnabled = input.bool(false, title="London: Enable Trend Filter")
londonTrendFilterMode = input.string("Both", title="London: Trend Mode", options=["With Trend", "Against Trend", "Both"])

// NY Session Settings (08:00-18:00 NY)
nyEnabled = input.bool(true, title="NY: Enable Session")
nyStopLossBuffer = input.int(3, title="NY: Stop Loss Buffer (ticks)", minval=1, maxval=20)
nySwingLookback = input.int(10, title="NY: Swing Lookback", minval=1, maxval=50)
nyRiskReward = input.float(2.0, title="NY: Risk:Reward Ratio", minval=0.5, maxval=10.0, step=0.5)
nyMaxRisk = input.float(100.0, title="NY: Max Risk Per Trade ($)", minval=1.0, step=10.0)
nyMaxCandles = input.int(15, title="NY: Max Candles to Signal", minval=5, maxval=50)
nyTimeFilterEnabled = input.bool(false, title="NY: Enable Time Filter")
nyStartHour = input.int(8, title="NY: Start Hour (NY)", minval=0, maxval=23)
nyEndHour = input.int(18, title="NY: End Hour (NY)", minval=0, maxval=23)
nyTrendFilterEnabled = input.bool(false, title="NY: Enable Trend Filter")
nyTrendFilterMode = input.string("Both", title="NY: Trend Mode", options=["With Trend", "Against Trend", "Both"])

// Colors
fvgColor = color.new(color.red, 80)
rejectionLineColor = color.new(color.orange, 0)
signalColor = color.new(color.green, 0)

// State variables for buy signals
var bool activeFvgSetup = false
var float fvgTop = na
var float fvgBottom = na
var int fvgBarIndex = na
var float rejectionHigh = na
var int rejectionBarIndex = na
var line rejectionLine = na
var int candlesSinceRejection = 0
var bool buySignalTriggered = false

// State variables for sell signals
var bool activeBullishFvgSetup = false
var float bullishFvgTop = na
var float bullishFvgBottom = na
var int bullishFvgBarIndex = na
var float rejectionLow = na
var int rejectionLowBarIndex = na
var line rejectionLowLine = na
var int candlesSinceRejectionLow = 0
var bool sellSignalTriggered = false

// Arrays to track stop loss lines and labels for both buy and sell signals
var array<line> buyStopLossLines = array.new<line>()
var array<label> buyStopLossLabels = array.new<label>()
var array<line> sellStopLossLines = array.new<line>()
var array<label> sellStopLossLabels = array.new<label>()

// Arrays to track take profit lines and labels for both buy and sell signals
var array<line> buyTakeProfitLines = array.new<line>()
var array<label> buyTakeProfitLabels = array.new<label>()
var array<line> sellTakeProfitLines = array.new<line>()
var array<label> sellTakeProfitLabels = array.new<label>()

// Arrays to track entry lines and labels for both buy and sell signals
var array<line> buyEntryLines = array.new<line>()
var array<label> buyEntryLabels = array.new<label>()
var array<line> sellEntryLines = array.new<line>()
var array<label> sellEntryLabels = array.new<label>()

// Variables to store latest alert messages
var string lastAlertMessage = ""

// Variables to track active trade (prevent overlapping signals)
var bool hasActiveTrade = false
var int activeTradeIndex = -1

// Arrays to track signal labels
var array<label> buySignalLabels = array.new<label>()
var array<label> sellSignalLabels = array.new<label>()

// Arrays to track trade performance
var array<float> tradeEntries = array.new<float>()
var array<float> tradeStopLosses = array.new<float>()
var array<float> tradeTakeProfits = array.new<float>()
var array<bool> tradeDirections = array.new<bool>()  // true = buy, false = sell
var array<int> tradeStartBars = array.new<int>()
var array<int> tradeTimestamps = array.new<int>()  // Store actual timestamp
var array<string> tradeOutcomes = array.new<string>()  // "win", "loss", "open"
var array<float> tradeRR = array.new<float>()  // Actual R:R achieved
var array<float> tradePnL = array.new<float>()  // P&L in dollars
var array<float> tradePositionSize = array.new<float>()  // Number of contracts
var array<string> tradeSessions = array.new<string>()  // Trading session: "Asia", "London", "NY"
var array<float> tradeATR = array.new<float>()  // ATR value at entry
var array<float> tradeFVGSize = array.new<float>()  // FVG size at entry (in price)
var array<float> tradeFVGPercent = array.new<float>()  // FVG size as % of ATR

// ATR for dynamic FVG size filtering
atr = ta.atr(14)

// Calculate trend indicator
trendLine = trendFilterType == "EMA" ? ta.ema(close, trendFilterLength) : ta.sma(close, trendFilterLength)

// Reset signal triggers at the start of each bar
buySignalTriggered := false
sellSignalTriggered := false

// Function to detect bullish FVG (for sell signals)
isBullishFvg() =>
    // Bullish FVG: gap between candle[2] high and current candle low
    gapExists = high[2] < low
    gapSize = gapExists ? low - high[2] : 0

    // Validate gap size if ATR filters are enabled
    gapMeetsMinimum = fvgMinSize > 0 ? gapSize > (atr * fvgMinSize) : true
    gapMeetsMaximum = fvgMaxSize > 0 ? gapSize < (atr * fvgMaxSize) : true

    gapExists and gapMeetsMinimum and gapMeetsMaximum

// Function to detect bearish FVG
isBearishFvg() =>
    // Bearish FVG: gap between candle[2] low and current candle high
    gapExists = low[2] > high
    gapSize = gapExists ? low[2] - high : 0

    // Validate gap size if ATR filters are enabled
    gapMeetsMinimum = fvgMinSize > 0 ? gapSize > (atr * fvgMinSize) : true
    gapMeetsMaximum = fvgMaxSize > 0 ? gapSize < (atr * fvgMaxSize) : true

    gapExists and gapMeetsMinimum and gapMeetsMaximum

// Function to check if price is in bearish FVG zone
priceInFvgZone(h, l) =>
    not na(fvgTop) and not na(fvgBottom) and h >= fvgBottom and l <= fvgTop

// Function to check if price is in bullish FVG zone
priceInBullishFvgZone(h, l) =>
    not na(bullishFvgTop) and not na(bullishFvgBottom) and l <= bullishFvgTop and h >= bullishFvgBottom

// Function to find recent swing low (for buy signal stop loss)
findRecentSwingLow(lookback) =>
    float swingLow = low[0]  // Start with current low
    for i = 0 to lookback
        if low[i] < swingLow
            swingLow := low[i]
    swingLow

// Function to find recent swing high (for sell signal stop loss)
findRecentSwingHigh(lookback) =>
    float swingHigh = high[0]  // Start with current high
    for i = 0 to lookback
        if high[i] > swingHigh
            swingHigh := high[i]
    swingHigh

// Function to detect trading session based on NY time
// Asia: 18:00-02:00, London: 02:00-08:00, NY: 08:00-18:00
getTradingSession() =>
    nyHour = hour(time, "America/New_York")
    if nyHour >= 18 or nyHour < 2
        "Asia"
    else if nyHour >= 2 and nyHour < 8
        "London"
    else
        "NY"

// Get session-specific stop loss buffer
getStopLossBuffer() =>
    if not useSessionSettings
        stopLossBuffer
    else
        string session = getTradingSession()
        session == "Asia" ? asiaStopLossBuffer : session == "London" ? londonStopLossBuffer : nyStopLossBuffer

// Get session-specific swing lookback
getSwingLookback() =>
    if not useSessionSettings
        swingLookback
    else
        string session = getTradingSession()
        session == "Asia" ? asiaSwingLookback : session == "London" ? londonSwingLookback : nySwingLookback

// Get session-specific risk:reward ratio
getRiskReward() =>
    if not useSessionSettings
        riskRewardRatio
    else
        string session = getTradingSession()
        session == "Asia" ? asiaRiskReward : session == "London" ? londonRiskReward : nyRiskReward

// Check if current session is enabled
isSessionEnabled() =>
    if not useSessionSettings
        true
    else
        string session = getTradingSession()
        session == "Asia" ? asiaEnabled : session == "London" ? londonEnabled : nyEnabled

// Check if trading is allowed in current session (time filter)
isSessionTradingAllowed() =>
    if not useSessionSettings
        true
    else
        string session = getTradingSession()
        nyHour = hour(time, "America/New_York")

        if session == "Asia"
            if not asiaTimeFilterEnabled
                true
            else
                nyHour >= asiaStartHour or nyHour < asiaEndHour
        else if session == "London"
            if not londonTimeFilterEnabled
                true
            else
                nyHour >= londonStartHour and nyHour < londonEndHour
        else  // NY
            if not nyTimeFilterEnabled
                true
            else
                nyHour >= nyStartHour and nyHour < nyEndHour

// Get session-specific trend filter mode
getSessionTrendMode() =>
    if not useSessionSettings
        trendFilterMode
    else
        string session = getTradingSession()
        session == "Asia" ? asiaTrendFilterMode : session == "London" ? londonTrendFilterMode : nyTrendFilterMode

// Check if trend filter is enabled for current session
isSessionTrendFilterEnabled() =>
    if not useSessionSettings
        enableTrendFilter
    else
        string session = getTradingSession()
        session == "Asia" ? asiaTrendFilterEnabled : session == "London" ? londonTrendFilterEnabled : nyTrendFilterEnabled

// Get session-specific max risk per trade
getMaxRiskPerTrade() =>
    if not useSessionSettings
        maxRiskPerTrade
    else
        string session = getTradingSession()
        session == "Asia" ? asiaMaxRisk : session == "London" ? londonMaxRisk : nyMaxRisk

// Get session-specific max candles to signal
getMaxCandlesToSignal() =>
    if not useSessionSettings
        maxCandlesToSignal
    else
        string session = getTradingSession()
        session == "Asia" ? asiaMaxCandles : session == "London" ? londonMaxCandles : nyMaxCandles

// Function to check if current time is within trading window (New York time)
isWithinTradingHours() =>
    if not enableTimeFilter
        true
    else
        // Get current hour and minute in New York timezone
        nyHour = hour(time, "America/New_York")
        nyMinute = minute(time, "America/New_York")
        currentMinutes = nyHour * 60 + nyMinute

        // Create start and end times in minutes
        startTimeMinutes = startHour * 60 + startMinute
        endTimeMinutes = endHour * 60 + endMinute

        // Check if current time is within range
        if startTimeMinutes <= endTimeMinutes
            // Normal case: e.g., 09:30 to 16:00 (same day)
            currentMinutes >= startTimeMinutes and currentMinutes <= endTimeMinutes
        else
            // Overnight case: e.g., 21:00 to 16:00 (crosses midnight)
            currentMinutes >= startTimeMinutes or currentMinutes <= endTimeMinutes

// Function to check if buy signal passes trend filter
allowBuySignal() =>
    bool trendEnabled = isSessionTrendFilterEnabled()
    string trendMode = getSessionTrendMode()

    if not trendEnabled
        true
    else if trendMode == "Both"
        true
    else if trendMode == "With Trend"
        close > trendLine  // Only buy when price is above trend line
    else  // "Against Trend"
        close < trendLine  // Only buy when price is below trend line

// Function to check if sell signal passes trend filter
allowSellSignal() =>
    bool trendEnabled = isSessionTrendFilterEnabled()
    string trendMode = getSessionTrendMode()

    if not trendEnabled
        true
    else if trendMode == "Both"
        true
    else if trendMode == "With Trend"
        close < trendLine  // Only sell when price is below trend line
    else  // "Against Trend"
        close > trendLine  // Only sell when price is above trend line

// BUY SIGNAL LOGIC (Bearish FVG Rejection)
if showBuySignals and isWithinTradingHours() and isSessionTradingAllowed() and isSessionEnabled()
    // Detect new bearish FVG
    if isBearishFvg()
        // Always reset and use the latest FVG
        // Reset previous setup
        if not na(rejectionLine)
            line.delete(rejectionLine)
        
        // Set up new FVG
        activeFvgSetup := true
        fvgTop := low[2]
        fvgBottom := high
        fvgBarIndex := bar_index
        rejectionHigh := na
        rejectionBarIndex := na
        rejectionLine := na
        candlesSinceRejection := 0
        
        // Draw FVG zone if enabled
        if showFvgZones
            box.new(bar_index - 2, fvgTop, bar_index + 20, fvgBottom, border_color=color.red, border_width=1, bgcolor=fvgColor, text="FVG", text_color=color.red)

    // Check for rejection candle (first candle touching FVG after formation)
    if activeFvgSetup and na(rejectionHigh) and bar_index > fvgBarIndex
        if priceInFvgZone(high, low)
            rejectionHigh := high
            rejectionBarIndex := bar_index
            candlesSinceRejection := 0
            
            // Draw rejection high line
            if showRejectionLines
                rejectionLine := line.new(bar_index, rejectionHigh, bar_index + lineExtension, rejectionHigh, color=rejectionLineColor, width=2, style=line.style_solid)
                label.new(bar_index, rejectionHigh, "RH", color=rejectionLineColor, style=label.style_label_down, size=size.small)

    // Track candles since rejection
    if activeFvgSetup and not na(rejectionHigh) and bar_index > rejectionBarIndex
        candlesSinceRejection := bar_index - rejectionBarIndex
        
        // Extend rejection line if still visible
        if not na(rejectionLine) and bar_index <= rejectionBarIndex + lineExtension
            line.set_x2(rejectionLine, bar_index + 1)

    // Check for trade signal (close above rejection high)
    if activeFvgSetup and not na(rejectionHigh) and close > rejectionHigh and allowBuySignal()
        if not hasActiveTrade
            buySignalTriggered := true
            hasActiveTrade := true

            // Calculate entry and stop loss (using session-specific settings)
            float entryPrice = close
            int sessionSwingLookback = getSwingLookback()
            int sessionStopBuffer = getStopLossBuffer()
            float swingLow = findRecentSwingLow(sessionSwingLookback)
            float stopLossPrice = swingLow - (sessionStopBuffer * syminfo.mintick)
            float stopDistance = entryPrice - stopLossPrice
            float stopDistanceTicks = stopDistance / syminfo.mintick

            // Check if stop loss exceeds maximum ticks filter
            bool stopLossTooLarge = maxStopLossTicks > 0 and stopDistanceTicks > maxStopLossTicks

            // Calculate position size based on risk management (using session-specific max risk)
            float positionSize = na
            if enableRiskManagement and stopDistanceTicks > 0 and not stopLossTooLarge
                float riskPerContract = stopDistanceTicks * dollarValuePerTick
                float sessionMaxRisk = getMaxRiskPerTrade()
                positionSize := math.floor(sessionMaxRisk / riskPerContract)

            // Visual signal with label tracking
            string buyLabel = "BUY"
            string skipReason = ""
            color labelColor = signalColor
            if stopLossTooLarge
                buyLabel := "SKIP\n(SL > " + str.tostring(maxStopLossTicks, "#") + " ticks)"
                skipReason := "SL too large"
                labelColor := color.orange
            else if enableRiskManagement
                if not na(positionSize) and positionSize > 0
                    buyLabel := "BUY\n" + str.tostring(positionSize, "#") + " contracts"
                else
                    buyLabel := "SKIP\n(Risk too high)"
                    skipReason := "Risk too high"
                    labelColor := color.orange

            // Check if we need to delete old signal labels
            if array.size(buySignalLabels) >= maxSignalLabels
                label oldSignalLabel = array.shift(buySignalLabels)
                label.delete(oldSignalLabel)

            // Create and track new signal label
            label newSignalLabel = label.new(bar_index, low, buyLabel, color=labelColor, style=label.style_label_up, size=size.normal)
            array.push(buySignalLabels, newSignalLabel)

            // Draw entry price line
            if showEntryLine
                // Check if we need to delete old projections
                if array.size(buyEntryLines) >= maxEntryProjections
                    // Delete oldest line and label
                    line oldEntryLine = array.shift(buyEntryLines)
                    label oldEntryLabel = array.shift(buyEntryLabels)
                    line.delete(oldEntryLine)
                    label.delete(oldEntryLabel)

                // Create new entry line and label
                line newEntryLine = line.new(bar_index, entryPrice, bar_index + lineExtension, entryPrice, color=color.blue, width=2, style=line.style_dashed)
                label newEntryLabel = label.new(bar_index + 2, entryPrice, "Entry: " + str.tostring(entryPrice, format.mintick), color=color.blue, style=label.style_label_left, size=size.small, textcolor=color.white)

                // Add to tracking arrays
                array.push(buyEntryLines, newEntryLine)
                array.push(buyEntryLabels, newEntryLabel)

            // Draw stop loss projection
            if showStopLoss
                // Check if we need to delete old projections
                if array.size(buyStopLossLines) >= maxStopLossProjections
                    // Delete oldest line and label
                    line oldLine = array.shift(buyStopLossLines)
                    label oldLabel = array.shift(buyStopLossLabels)
                    line.delete(oldLine)
                    label.delete(oldLabel)

                // Create new stop loss line and label
                line newLine = line.new(bar_index, stopLossPrice, bar_index + lineExtension, stopLossPrice, color=color.red, width=2, style=line.style_dashed)
                label newLabel = label.new(bar_index + 2, stopLossPrice, "SL: " + str.tostring(stopDistanceTicks, "#") + " ticks", color=color.red, style=label.style_label_left, size=size.small, textcolor=color.white)

                // Add to tracking arrays
                array.push(buyStopLossLines, newLine)
                array.push(buyStopLossLabels, newLabel)

            // Draw take profit projection
            if showTakeProfit
                // Calculate take profit based on session-specific risk:reward ratio
                float sessionRR = getRiskReward()
                float takeProfitPrice = entryPrice + (stopDistance * sessionRR)
                float takeProfitDistanceTicks = (takeProfitPrice - entryPrice) / syminfo.mintick

                // Check if we need to delete old projections
                if array.size(buyTakeProfitLines) >= maxTakeProfitProjections
                    // Delete oldest line and label
                    line oldTpLine = array.shift(buyTakeProfitLines)
                    label oldTpLabel = array.shift(buyTakeProfitLabels)
                    line.delete(oldTpLine)
                    label.delete(oldTpLabel)

                // Create new take profit line and label
                line newTpLine = line.new(bar_index, takeProfitPrice, bar_index + lineExtension, takeProfitPrice, color=color.green, width=2, style=line.style_dashed)
                label newTpLabel = label.new(bar_index + 2, takeProfitPrice, "TP: " + str.tostring(takeProfitDistanceTicks, "#") + " ticks", color=color.green, style=label.style_label_left, size=size.small, textcolor=color.white)

                // Add to tracking arrays
                array.push(buyTakeProfitLines, newTpLine)
                array.push(buyTakeProfitLabels, newTpLabel)

            // Track trade for performance stats
            float sessionRR = getRiskReward()
            float takeProfitPrice = entryPrice + (stopDistance * sessionRR)

            // Calculate FVG size (bearish FVG: gap between low[2] and high at formation)
            float currentFvgSize = fvgTop - fvgBottom  // Already stored from FVG detection
            float fvgPercentOfATR = atr > 0 ? (currentFvgSize / atr) * 100 : 0

            array.push(tradeEntries, entryPrice)
            array.push(tradeStopLosses, stopLossPrice)
            array.push(tradeTakeProfits, takeProfitPrice)
            array.push(tradeDirections, true)  // true = buy
            array.push(tradeStartBars, bar_index)
            array.push(tradeTimestamps, time)  // Store current bar's timestamp
            array.push(tradeOutcomes, "open")
            array.push(tradeRR, 0.0)
            array.push(tradePnL, 0.0)
            array.push(tradePositionSize, na(positionSize) ? 1.0 : positionSize)
            array.push(tradeSessions, getTradingSession())  // Store session
            array.push(tradeATR, atr)  // Store ATR at entry
            array.push(tradeFVGSize, currentFvgSize)  // Store FVG size
            array.push(tradeFVGPercent, fvgPercentOfATR)  // Store FVG as % of ATR

            // Set active trade index
            activeTradeIndex := array.size(tradeOutcomes) - 1

            // Alert - only fire when bar is confirmed (closed)
            if barstate.isconfirmed
                string signalText = ""
                if stopLossTooLarge or (enableRiskManagement and (na(positionSize) or positionSize <= 0))
                    string reason = stopLossTooLarge ? "SL too large" : "Risk too high"
                    signalText := syminfo.ticker + " BUY Signal SKIPPED (" + reason + ") | Entry: " + str.tostring(entryPrice, format.mintick) + " | SL: " + str.tostring(stopLossPrice, format.mintick) + " (" + str.tostring(stopDistanceTicks, "#") + " ticks) | TP: " + str.tostring(takeProfitPrice, format.mintick)
                else
                    signalText := syminfo.ticker + " BUY Signal | Entry: " + str.tostring(entryPrice, format.mintick) + " | SL: " + str.tostring(stopLossPrice, format.mintick) + " | TP: " + str.tostring(takeProfitPrice, format.mintick)
                    if enableRiskManagement and not na(positionSize)
                        signalText := signalText + " | Contracts: " + str.tostring(positionSize, "#")

                // Fire clean alert for TradingView
                lastAlertMessage := signalText
                alert(signalText, alert.freq_once_per_bar)

                // Also fire Discord-formatted alert if enabled
                if formatForDiscord
                    string emoji = (enableRiskManagement and (na(positionSize) or positionSize <= 0)) ? "âš ï¸" : "ðŸŸ¢"
                    string discordMsg = '{"content": "' + emoji + ' ' + signalText + '"}'
                    alert(discordMsg, alert.freq_once_per_bar)
        else
            // Setup was triggered during an active trade - invalidate it to prevent delayed signal
            activeFvgSetup := false
            rejectionHigh := na

    // Note: New FVG invalidation is now handled in the FVG detection section above
    // This prevents false invalidations from FVGs detected in the same area
    
    // Invalidation: Timeout (using session-specific max candles)
    int sessionMaxCandles = getMaxCandlesToSignal()
    if activeFvgSetup and not na(rejectionHigh) and candlesSinceRejection > sessionMaxCandles
        activeFvgSetup := false
        if not na(rejectionLine)
            line.set_color(rejectionLine, color.gray)
            label.new(bar_index, high, "TO", color=color.gray, style=label.style_label_down, size=size.small)

// SELL SIGNAL LOGIC (Bullish FVG Rejection)
if showSellSignals and isWithinTradingHours() and isSessionTradingAllowed() and isSessionEnabled()
    // Detect new bullish FVG
    if isBullishFvg()
        // Always reset and use the latest FVG
        // Reset previous setup
        if not na(rejectionLowLine)
            line.delete(rejectionLowLine)
        
        // Set up new FVG
        activeBullishFvgSetup := true
        bullishFvgTop := low
        bullishFvgBottom := high[2]
        bullishFvgBarIndex := bar_index
        rejectionLow := na
        rejectionLowBarIndex := na
        rejectionLowLine := na
        candlesSinceRejectionLow := 0
        
        // Draw FVG zone if enabled
        if showFvgZones
            box.new(bar_index - 2, bullishFvgTop, bar_index + 20, bullishFvgBottom, border_color=color.green, border_width=1, bgcolor=color.new(color.green, 80), text="FVG", text_color=color.green)
    
    // Check for rejection candle (first candle touching bullish FVG after formation)
    if activeBullishFvgSetup and na(rejectionLow) and bar_index > bullishFvgBarIndex
        if priceInBullishFvgZone(high, low)
            rejectionLow := low
            rejectionLowBarIndex := bar_index
            candlesSinceRejectionLow := 0
            
            // Draw rejection low line
            if showRejectionLines
                rejectionLowLine := line.new(bar_index, rejectionLow, bar_index + lineExtension, rejectionLow, color=color.blue, width=2, style=line.style_solid)
                label.new(bar_index, rejectionLow, "RL", color=color.blue, style=label.style_label_up, size=size.small)
    
    // Track candles since rejection
    if activeBullishFvgSetup and not na(rejectionLow) and bar_index > rejectionLowBarIndex
        candlesSinceRejectionLow := bar_index - rejectionLowBarIndex
        
        // Extend rejection line if still visible
        if not na(rejectionLowLine) and bar_index <= rejectionLowBarIndex + lineExtension
            line.set_x2(rejectionLowLine, bar_index + 1)
    
    // Check for sell signal (close below rejection low)
    if activeBullishFvgSetup and not na(rejectionLow) and close < rejectionLow and allowSellSignal()
        if not hasActiveTrade
            sellSignalTriggered := true
            activeBullishFvgSetup := false
            hasActiveTrade := true

            // Calculate entry and stop loss (using session-specific settings)
            float entryPrice = close
            int sessionSwingLookback = getSwingLookback()
            int sessionStopBuffer = getStopLossBuffer()
            float swingHigh = findRecentSwingHigh(sessionSwingLookback)
            float stopLossPrice = swingHigh + (sessionStopBuffer * syminfo.mintick)
            float stopDistance = stopLossPrice - entryPrice
            float stopDistanceTicks = stopDistance / syminfo.mintick

            // Check if stop loss exceeds maximum ticks filter
            bool stopLossTooLarge = maxStopLossTicks > 0 and stopDistanceTicks > maxStopLossTicks

            // Calculate position size based on risk management (using session-specific max risk)
            float positionSize = na
            if enableRiskManagement and stopDistanceTicks > 0 and not stopLossTooLarge
                float riskPerContract = stopDistanceTicks * dollarValuePerTick
                float sessionMaxRisk = getMaxRiskPerTrade()
                positionSize := math.floor(sessionMaxRisk / riskPerContract)

            // Visual signal with label tracking
            string sellLabel = "SELL"
            string skipReason = ""
            color labelColor = color.red
            if stopLossTooLarge
                sellLabel := "SKIP\n(SL > " + str.tostring(maxStopLossTicks, "#") + " ticks)"
                skipReason := "SL too large"
                labelColor := color.orange
            else if enableRiskManagement
                if not na(positionSize) and positionSize > 0
                    sellLabel := "SELL\n" + str.tostring(positionSize, "#") + " contracts"
                else
                    sellLabel := "SKIP\n(Risk too high)"
                    skipReason := "Risk too high"
                    labelColor := color.orange

            // Check if we need to delete old signal labels
            if array.size(sellSignalLabels) >= maxSignalLabels
                label oldSignalLabel = array.shift(sellSignalLabels)
                label.delete(oldSignalLabel)

            // Create and track new signal label
            label newSignalLabel = label.new(bar_index, high, sellLabel, color=labelColor, style=label.style_label_down, size=size.normal)
            array.push(sellSignalLabels, newSignalLabel)

            // Draw entry price line
            if showEntryLine
                // Check if we need to delete old projections
                if array.size(sellEntryLines) >= maxEntryProjections
                    // Delete oldest line and label
                    line oldEntryLine = array.shift(sellEntryLines)
                    label oldEntryLabel = array.shift(sellEntryLabels)
                    line.delete(oldEntryLine)
                    label.delete(oldEntryLabel)

                // Create new entry line and label
                line newEntryLine = line.new(bar_index, entryPrice, bar_index + lineExtension, entryPrice, color=color.blue, width=2, style=line.style_dashed)
                label newEntryLabel = label.new(bar_index + 2, entryPrice, "Entry: " + str.tostring(entryPrice, format.mintick), color=color.blue, style=label.style_label_left, size=size.small, textcolor=color.white)

                // Add to tracking arrays
                array.push(sellEntryLines, newEntryLine)
                array.push(sellEntryLabels, newEntryLabel)

            // Draw stop loss projection
            if showStopLoss
                // Check if we need to delete old projections
                if array.size(sellStopLossLines) >= maxStopLossProjections
                    // Delete oldest line and label
                    line oldLine = array.shift(sellStopLossLines)
                    label oldLabel = array.shift(sellStopLossLabels)
                    line.delete(oldLine)
                    label.delete(oldLabel)

                // Create new stop loss line and label
                line newLine = line.new(bar_index, stopLossPrice, bar_index + lineExtension, stopLossPrice, color=color.red, width=2, style=line.style_dashed)
                label newLabel = label.new(bar_index + 2, stopLossPrice, "SL: " + str.tostring(stopDistanceTicks, "#") + " ticks", color=color.red, style=label.style_label_left, size=size.small, textcolor=color.white)

                // Add to tracking arrays
                array.push(sellStopLossLines, newLine)
                array.push(sellStopLossLabels, newLabel)

            // Draw take profit projection
            if showTakeProfit
                // Calculate take profit based on session-specific risk:reward ratio
                float sessionRR = getRiskReward()
                float takeProfitPrice = entryPrice - (stopDistance * sessionRR)
                float takeProfitDistanceTicks = (entryPrice - takeProfitPrice) / syminfo.mintick

                // Check if we need to delete old projections
                if array.size(sellTakeProfitLines) >= maxTakeProfitProjections
                    // Delete oldest line and label
                    line oldTpLine = array.shift(sellTakeProfitLines)
                    label oldTpLabel = array.shift(sellTakeProfitLabels)
                    line.delete(oldTpLine)
                    label.delete(oldTpLabel)

                // Create new take profit line and label
                line newTpLine = line.new(bar_index, takeProfitPrice, bar_index + lineExtension, takeProfitPrice, color=color.green, width=2, style=line.style_dashed)
                label newTpLabel = label.new(bar_index + 2, takeProfitPrice, "TP: " + str.tostring(takeProfitDistanceTicks, "#") + " ticks", color=color.green, style=label.style_label_left, size=size.small, textcolor=color.white)

                // Add to tracking arrays
                array.push(sellTakeProfitLines, newTpLine)
                array.push(sellTakeProfitLabels, newTpLabel)

            // Track trade for performance stats
            float sessionRR = getRiskReward()
            float takeProfitPrice = entryPrice - (stopDistance * sessionRR)

            // Calculate FVG size (bullish FVG: gap between high[2] and low at formation)
            float currentFvgSize = bullishFvgTop - bullishFvgBottom  // Already stored from FVG detection
            float fvgPercentOfATR = atr > 0 ? (currentFvgSize / atr) * 100 : 0

            array.push(tradeEntries, entryPrice)
            array.push(tradeStopLosses, stopLossPrice)
            array.push(tradeTakeProfits, takeProfitPrice)
            array.push(tradeDirections, false)  // false = sell
            array.push(tradeStartBars, bar_index)
            array.push(tradeTimestamps, time)  // Store current bar's timestamp
            array.push(tradeOutcomes, "open")
            array.push(tradeRR, 0.0)
            array.push(tradePnL, 0.0)
            array.push(tradePositionSize, na(positionSize) ? 1.0 : positionSize)
            array.push(tradeSessions, getTradingSession())  // Store session
            array.push(tradeATR, atr)  // Store ATR at entry
            array.push(tradeFVGSize, currentFvgSize)  // Store FVG size
            array.push(tradeFVGPercent, fvgPercentOfATR)  // Store FVG as % of ATR

            // Set active trade index
            activeTradeIndex := array.size(tradeOutcomes) - 1

            // Alert - only fire when bar is confirmed (closed)
            if barstate.isconfirmed
                string signalText = ""
                if stopLossTooLarge or (enableRiskManagement and (na(positionSize) or positionSize <= 0))
                    string reason = stopLossTooLarge ? "SL too large" : "Risk too high"
                    signalText := syminfo.ticker + " SELL Signal SKIPPED (" + reason + ") | Entry: " + str.tostring(entryPrice, format.mintick) + " | SL: " + str.tostring(stopLossPrice, format.mintick) + " (" + str.tostring(stopDistanceTicks, "#") + " ticks) | TP: " + str.tostring(takeProfitPrice, format.mintick)
                else
                    signalText := syminfo.ticker + " SELL Signal | Entry: " + str.tostring(entryPrice, format.mintick) + " | SL: " + str.tostring(stopLossPrice, format.mintick) + " | TP: " + str.tostring(takeProfitPrice, format.mintick)
                    if enableRiskManagement and not na(positionSize)
                        signalText := signalText + " | Contracts: " + str.tostring(positionSize, "#")

                // Fire clean alert for TradingView
                lastAlertMessage := signalText
                alert(signalText, alert.freq_once_per_bar)

                // Also fire Discord-formatted alert if enabled
                if formatForDiscord
                    string emoji = (enableRiskManagement and (na(positionSize) or positionSize <= 0)) ? "âš ï¸" : "ðŸ”´"
                    string discordMsg = '{"content": "' + emoji + ' ' + signalText + '"}'
                    alert(discordMsg, alert.freq_once_per_bar)
        else
            // Setup was triggered during an active trade - invalidate it to prevent delayed signal
            activeBullishFvgSetup := false
            rejectionLow := na
    
    // Invalidation: Timeout (using session-specific max candles)
    int sessionMaxCandlesSell = getMaxCandlesToSignal()
    if activeBullishFvgSetup and not na(rejectionLow) and candlesSinceRejectionLow > sessionMaxCandlesSell
        activeBullishFvgSetup := false
        if not na(rejectionLowLine)
            line.set_color(rejectionLowLine, color.gray)
            label.new(bar_index, low, "TO", color=color.gray, style=label.style_label_up, size=size.small)

// Check open trades and update outcomes
if array.size(tradeOutcomes) > 0
    for i = 0 to array.size(tradeOutcomes) - 1
        if array.get(tradeOutcomes, i) == "open"
            float tradeEntry = array.get(tradeEntries, i)
            float tradeSL = array.get(tradeStopLosses, i)
            float tradeTP = array.get(tradeTakeProfits, i)
            bool isBuyTrade = array.get(tradeDirections, i)

            if isBuyTrade
                // Check if TP or SL hit for buy trade
                if high >= tradeTP
                    array.set(tradeOutcomes, i, "win")
                    float actualRR = (tradeTP - tradeEntry) / (tradeEntry - tradeSL)
                    array.set(tradeRR, i, actualRR)
                    // Calculate P&L in dollars
                    float pnlTicks = (tradeTP - tradeEntry) / syminfo.mintick
                    float contracts = array.get(tradePositionSize, i)
                    float pnlDollars = pnlTicks * dollarValuePerTick * contracts
                    array.set(tradePnL, i, pnlDollars)

                    // Send TP alert if enabled (triggers immediately when hit)
                    if enableTPSLAlerts
                        string tpText = syminfo.ticker + " BUY Take Profit HIT | Entry: " + str.tostring(tradeEntry, format.mintick) + " | Exit: " + str.tostring(tradeTP, format.mintick) + " | P&L: $" + str.tostring(pnlDollars, "#.##")
                        alert(tpText, alert.freq_once_per_bar)
                        if formatForDiscord
                            string discordTP = '{"content": "âœ… ' + tpText + '"}'
                            alert(discordTP, alert.freq_once_per_bar)

                    // Clear active trade if this was the active one
                    if i == activeTradeIndex
                        hasActiveTrade := false
                        activeTradeIndex := -1
                else if low <= tradeSL
                    array.set(tradeOutcomes, i, "loss")
                    array.set(tradeRR, i, -1.0)
                    // Calculate P&L in dollars (negative)
                    float pnlTicks = (tradeSL - tradeEntry) / syminfo.mintick
                    float contracts = array.get(tradePositionSize, i)
                    float pnlDollars = pnlTicks * dollarValuePerTick * contracts
                    array.set(tradePnL, i, pnlDollars)

                    // Send SL alert if enabled (triggers immediately when hit)
                    if enableTPSLAlerts
                        string slText = syminfo.ticker + " BUY Stop Loss HIT | Entry: " + str.tostring(tradeEntry, format.mintick) + " | Exit: " + str.tostring(tradeSL, format.mintick) + " | P&L: $" + str.tostring(pnlDollars, "#.##")
                        alert(slText, alert.freq_once_per_bar)
                        if formatForDiscord
                            string discordSL = '{"content": "âŒ ' + slText + '"}'
                            alert(discordSL, alert.freq_once_per_bar)

                    // Clear active trade if this was the active one
                    if i == activeTradeIndex
                        hasActiveTrade := false
                        activeTradeIndex := -1
            else
                // Check if TP or SL hit for sell trade
                if low <= tradeTP
                    array.set(tradeOutcomes, i, "win")
                    float actualRR = (tradeEntry - tradeTP) / (tradeSL - tradeEntry)
                    array.set(tradeRR, i, actualRR)
                    // Calculate P&L in dollars
                    float pnlTicks = (tradeEntry - tradeTP) / syminfo.mintick
                    float contracts = array.get(tradePositionSize, i)
                    float pnlDollars = pnlTicks * dollarValuePerTick * contracts
                    array.set(tradePnL, i, pnlDollars)

                    // Send TP alert if enabled (triggers immediately when hit)
                    if enableTPSLAlerts
                        string tpText = syminfo.ticker + " SELL Take Profit HIT | Entry: " + str.tostring(tradeEntry, format.mintick) + " | Exit: " + str.tostring(tradeTP, format.mintick) + " | P&L: $" + str.tostring(pnlDollars, "#.##")
                        alert(tpText, alert.freq_once_per_bar)
                        if formatForDiscord
                            string discordTP = '{"content": "âœ… ' + tpText + '"}'
                            alert(discordTP, alert.freq_once_per_bar)

                    // Clear active trade if this was the active one
                    if i == activeTradeIndex
                        hasActiveTrade := false
                        activeTradeIndex := -1
                else if high >= tradeSL
                    array.set(tradeOutcomes, i, "loss")
                    array.set(tradeRR, i, -1.0)
                    // Calculate P&L in dollars (negative)
                    float pnlTicks = (tradeEntry - tradeSL) / syminfo.mintick
                    float contracts = array.get(tradePositionSize, i)
                    float pnlDollars = pnlTicks * dollarValuePerTick * contracts
                    array.set(tradePnL, i, pnlDollars)

                    // Send SL alert if enabled (triggers immediately when hit)
                    if enableTPSLAlerts
                        string slText = syminfo.ticker + " SELL Stop Loss HIT | Entry: " + str.tostring(tradeEntry, format.mintick) + " | Exit: " + str.tostring(tradeSL, format.mintick) + " | P&L: $" + str.tostring(pnlDollars, "#.##")
                        alert(slText, alert.freq_once_per_bar)
                        if formatForDiscord
                            string discordSL = '{"content": "âŒ ' + slText + '"}'
                            alert(discordSL, alert.freq_once_per_bar)

                    // Clear active trade if this was the active one
                    if i == activeTradeIndex
                        hasActiveTrade := false
                        activeTradeIndex := -1

// Calculate statistics
var int totalTrades = 0
var int buyTrades = 0
var int sellTrades = 0
var int wins = 0
var int losses = 0
var float totalPnL = 0.0
var float bestPnL = 0.0
var float worstPnL = 0.0

if barstate.islast and showStatsTable
    totalTrades := 0
    wins := 0
    losses := 0
    totalPnL := 0.0
    bestPnL := 0.0
    worstPnL := 0.0
    buyTrades := 0
    sellTrades := 0

    // Drawdown tracking
    float maxDrawdown = 0.0
    float peakPnL = 0.0
    float runningPnL = 0.0

    // Session-specific stats
    float asiaPnL = 0.0
    int asiaWins = 0
    int asiaLosses = 0
    float londonPnL = 0.0
    int londonWins = 0
    int londonLosses = 0
    float nyPnL = 0.0
    int nyWins = 0
    int nyLosses = 0

    // ATR Analysis variables
    float winningATRSum = 0.0
    int winningATRCount = 0
    float losingATRSum = 0.0
    int losingATRCount = 0
    float winningFVGSum = 0.0
    float losingFVGSum = 0.0

    // FVG Size buckets (as % of ATR)
    int fvgUnder30 = 0
    int fvgUnder30Wins = 0
    int fvg30to60 = 0
    int fvg30to60Wins = 0
    int fvg60to100 = 0
    int fvg60to100Wins = 0
    int fvgOver100 = 0
    int fvgOver100Wins = 0

    // Get current time range based on stats timeframe filter
    bool filterByTime = statsTimeframe == "Current Session" or statsTimeframe == "Current Week"
    bool filterBySession = statsTimeframe == "Current Session"
    bool filterByWeek = statsTimeframe == "Current Week"

    int currentHour = hour(time, "America/New_York")
    int currentDay = dayofweek(time, "America/New_York")  // Sunday = 1, Monday = 2, etc.
    int sessionStart = 0
    int sessionEnd = 0

    if filterBySession
        // Determine which session we're in
        if currentHour >= sessionStartHour
            // We're in today's session (started today at sessionStartHour)
            sessionStart := timestamp(year, month, dayofmonth, sessionStartHour, 0, 0)
            // Session ends tomorrow at (sessionStartHour - 1):59:59
            sessionEnd := timestamp(year, month, dayofmonth + 1, sessionStartHour - 1, 59, 59)
        else
            // We're still in yesterday's session (which started yesterday at sessionStartHour)
            sessionStart := timestamp(year, month, dayofmonth - 1, sessionStartHour, 0, 0)
            // Session ends today at (sessionStartHour - 1):59:59
            sessionEnd := timestamp(year, month, dayofmonth, sessionStartHour - 1, 59, 59)

    if filterByWeek
        // Week starts Sunday 18:00 NY, ends Friday 17:00 NY
        int daysFromSunday = currentDay == 1 ? 0 : currentDay - 1  // Days since last Sunday

        // If it's Sunday but before 18:00, we're still in last week
        if currentDay == 1 and currentHour < 18
            daysFromSunday := 7

        // If it's after Friday 17:00, we're already into next week's start period
        if currentDay == 6 and currentHour >= 17
            daysFromSunday := -1  // Start of next week

        // Calculate week start (last Sunday at 18:00)
        sessionStart := timestamp(year, month, dayofmonth - daysFromSunday, 18, 0, 0)
        // Calculate week end (this Friday at 17:00)
        int daysToFriday = (6 - currentDay + 7) % 7
        if currentDay == 6 and currentHour >= 17
            daysToFriday := 5
        sessionEnd := timestamp(year, month, dayofmonth + daysToFriday, 17, 0, 0)

    for i = 0 to array.size(tradeOutcomes) - 1
        int tradeTime = array.get(tradeTimestamps, i)

        // Skip if filtering by time period and trade wasn't in current period
        if filterByTime and (tradeTime < sessionStart or tradeTime > sessionEnd)
            continue

        // Count this trade
        totalTrades := totalTrades + 1

        if array.get(tradeDirections, i)
            buyTrades := buyTrades + 1
        else
            sellTrades := sellTrades + 1

        string outcome = array.get(tradeOutcomes, i)
        float pnl = array.get(tradePnL, i)
        string session = array.get(tradeSessions, i)

        // Get ATR and FVG data for this trade
        float tradeAtrValue = array.get(tradeATR, i)
        float tradeFvgPercent = array.get(tradeFVGPercent, i)

        // Track FVG size buckets
        if tradeFvgPercent < 30
            fvgUnder30 := fvgUnder30 + 1
            if outcome == "win"
                fvgUnder30Wins := fvgUnder30Wins + 1
        else if tradeFvgPercent < 60
            fvg30to60 := fvg30to60 + 1
            if outcome == "win"
                fvg30to60Wins := fvg30to60Wins + 1
        else if tradeFvgPercent < 100
            fvg60to100 := fvg60to100 + 1
            if outcome == "win"
                fvg60to100Wins := fvg60to100Wins + 1
        else
            fvgOver100 := fvgOver100 + 1
            if outcome == "win"
                fvgOver100Wins := fvgOver100Wins + 1

        if outcome == "win"
            wins := wins + 1
            totalPnL := totalPnL + pnl
            if pnl > bestPnL or bestPnL == 0.0
                bestPnL := pnl

            // Track ATR for winning trades
            winningATRSum := winningATRSum + tradeAtrValue
            winningFVGSum := winningFVGSum + tradeFvgPercent
            winningATRCount := winningATRCount + 1

            // Track session-specific wins
            if session == "Asia"
                asiaWins := asiaWins + 1
                asiaPnL := asiaPnL + pnl
            else if session == "London"
                londonWins := londonWins + 1
                londonPnL := londonPnL + pnl
            else if session == "NY"
                nyWins := nyWins + 1
                nyPnL := nyPnL + pnl

        else if outcome == "loss"
            losses := losses + 1
            totalPnL := totalPnL + pnl
            if pnl < worstPnL
                worstPnL := pnl

            // Track ATR for losing trades
            losingATRSum := losingATRSum + tradeAtrValue
            losingFVGSum := losingFVGSum + tradeFvgPercent
            losingATRCount := losingATRCount + 1

            // Track session-specific losses
            if session == "Asia"
                asiaLosses := asiaLosses + 1
                asiaPnL := asiaPnL + pnl
            else if session == "London"
                londonLosses := londonLosses + 1
                londonPnL := londonPnL + pnl
            else if session == "NY"
                nyLosses := nyLosses + 1
                nyPnL := nyPnL + pnl

        // Calculate drawdown after each completed trade
        if outcome == "win" or outcome == "loss"
            runningPnL := runningPnL + pnl

            // Update peak if we hit a new high
            if runningPnL > peakPnL
                peakPnL := runningPnL

            // Calculate current drawdown from peak
            float currentDrawdown = peakPnL - runningPnL

            // Update max drawdown if current is worse
            if currentDrawdown > maxDrawdown
                maxDrawdown := currentDrawdown

    // Create stats table
    tablePos = statsTablePosition == "Top Left" ? position.top_left :
               statsTablePosition == "Top Right" ? position.top_right :
               statsTablePosition == "Bottom Left" ? position.bottom_left : position.bottom_right

    // Calculate rows needed: base (9 with drawdown) + session stats (4 if enabled) + ATR analysis (11 if trades exist)
    int tableRows = showSessionStats ? 24 : 20
    statsTable = table.new(tablePos, 2, tableRows, border_width=1)

    // Header
    string sessionInfo = ""
    if statsTimeframe == "Current Session"
        sessionInfo := "Current Session\n(" + str.tostring(sessionStartHour) + ":00-" + str.tostring(sessionStartHour - 1) + ":00 NY)"
    else if statsTimeframe == "Current Week"
        sessionInfo := "Current Week\n(Sun 18:00 - Fri 17:00 NY)"
    else
        sessionInfo := statsTimeframe

    string headerText = "Performance Stats\n" + sessionInfo
    table.cell(statsTable, 0, 0, headerText, bgcolor=color.new(color.gray, 30), text_color=color.white, text_size=size.large)
    table.merge_cells(statsTable, 0, 0, 1, 0)

    // Total signals
    table.cell(statsTable, 0, 1, "Total Signals:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 1, str.tostring(totalTrades), bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)

    // Buy/Sell breakdown
    table.cell(statsTable, 0, 2, "Buy / Sell:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 2, str.tostring(buyTrades) + " / " + str.tostring(sellTrades), bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)

    // Wins
    table.cell(statsTable, 0, 3, "Wins:", bgcolor=color.new(color.green, 70), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 3, str.tostring(wins), bgcolor=color.new(color.green, 70), text_color=color.white, text_size=size.normal)

    // Losses
    table.cell(statsTable, 0, 4, "Losses:", bgcolor=color.new(color.red, 70), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 4, str.tostring(losses), bgcolor=color.new(color.red, 70), text_color=color.white, text_size=size.normal)

    // Win rate
    float winRate = totalTrades > 0 and (wins + losses) > 0 ? (wins / (wins + losses)) * 100 : 0
    color winRateColor = winRate >= 50 ? color.green : color.red
    table.cell(statsTable, 0, 5, "Win Rate:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 5, str.tostring(winRate, "#.##") + "%", bgcolor=color.new(winRateColor, 70), text_color=color.white, text_size=size.normal)

    // Net P&L
    color pnlColor = totalPnL >= 0 ? color.green : color.red
    table.cell(statsTable, 0, 6, "Net P&L:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 6, "$" + str.tostring(totalPnL, "#.##"), bgcolor=color.new(pnlColor, 70), text_color=color.white, text_size=size.normal)

    // Best/Worst trade
    table.cell(statsTable, 0, 7, "Best / Worst:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 7, "$" + str.tostring(bestPnL, "#.##") + " / $" + str.tostring(worstPnL, "#.##"), bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)

    // Max Drawdown
    table.cell(statsTable, 0, 8, "Max Drawdown:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.normal)
    table.cell(statsTable, 1, 8, "$" + str.tostring(maxDrawdown, "#.##"), bgcolor=color.new(color.red, 70), text_color=color.white, text_size=size.normal)

    // Session breakdown (if enabled)
    if showSessionStats
        // Session header
        table.cell(statsTable, 0, 9, "Session Breakdown", bgcolor=color.new(color.blue, 50), text_color=color.white, text_size=size.normal)
        table.merge_cells(statsTable, 0, 9, 1, 9)

        // Asia session
        int asiaTrades = asiaWins + asiaLosses
        float asiaWR = asiaTrades > 0 ? (asiaWins / asiaTrades) * 100 : 0
        table.cell(statsTable, 0, 10, "Asia (18:00-02:00):", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.small)
        string asiaStats = str.tostring(asiaTrades) + " | " + str.tostring(asiaWR, "#") + "% | $" + str.tostring(asiaPnL, "#.##")
        color asiaColor = asiaPnL >= 0 ? color.green : color.red
        table.cell(statsTable, 1, 10, asiaStats, bgcolor=color.new(asiaColor, 80), text_color=color.white, text_size=size.small)

        // London session
        int londonTrades = londonWins + londonLosses
        float londonWR = londonTrades > 0 ? (londonWins / londonTrades) * 100 : 0
        table.cell(statsTable, 0, 11, "London (02:00-08:00):", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.small)
        string londonStats = str.tostring(londonTrades) + " | " + str.tostring(londonWR, "#") + "% | $" + str.tostring(londonPnL, "#.##")
        color londonColor = londonPnL >= 0 ? color.green : color.red
        table.cell(statsTable, 1, 11, londonStats, bgcolor=color.new(londonColor, 80), text_color=color.white, text_size=size.small)

        // NY session
        int nyTrades = nyWins + nyLosses
        float nyWR = nyTrades > 0 ? (nyWins / nyTrades) * 100 : 0
        table.cell(statsTable, 0, 12, "NY (08:00-18:00):", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.small)
        string nyStats = str.tostring(nyTrades) + " | " + str.tostring(nyWR, "#") + "% | $" + str.tostring(nyPnL, "#.##")
        color nyColor = nyPnL >= 0 ? color.green : color.red
        table.cell(statsTable, 1, 12, nyStats, bgcolor=color.new(nyColor, 80), text_color=color.white, text_size=size.small)

    // ATR Analysis section (always show if we have trades)
    int atrRowStart = showSessionStats ? 13 : 9
    if totalTrades > 0
        // ATR Analysis header
        table.cell(statsTable, 0, atrRowStart, "ATR Analysis", bgcolor=color.new(color.purple, 50), text_color=color.white, text_size=size.normal)
        table.merge_cells(statsTable, 0, atrRowStart, 1, atrRowStart)

        // Calculate averages
        float avgWinningATR = winningATRCount > 0 ? winningATRSum / winningATRCount : 0
        float avgLosingATR = losingATRCount > 0 ? losingATRSum / losingATRCount : 0
        float avgWinningFVG = winningATRCount > 0 ? winningFVGSum / winningATRCount : 0
        float avgLosingFVG = losingATRCount > 0 ? losingFVGSum / losingATRCount : 0

        // Winning trades ATR
        table.cell(statsTable, 0, atrRowStart + 1, "Wins - Avg ATR:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, atrRowStart + 1, str.tostring(avgWinningATR, "#.##"), bgcolor=color.new(color.green, 80), text_color=color.white, text_size=size.small)

        // Losing trades ATR
        table.cell(statsTable, 0, atrRowStart + 2, "Losses - Avg ATR:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, atrRowStart + 2, str.tostring(avgLosingATR, "#.##"), bgcolor=color.new(color.red, 80), text_color=color.white, text_size=size.small)

        // Winning trades FVG %
        table.cell(statsTable, 0, atrRowStart + 3, "Wins - Avg FVG%:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, atrRowStart + 3, str.tostring(avgWinningFVG, "#") + "%", bgcolor=color.new(color.green, 80), text_color=color.white, text_size=size.small)

        // Losing trades FVG %
        table.cell(statsTable, 0, atrRowStart + 4, "Losses - Avg FVG%:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, atrRowStart + 4, str.tostring(avgLosingFVG, "#") + "%", bgcolor=color.new(color.red, 80), text_color=color.white, text_size=size.small)

        // FVG Size Buckets header
        table.cell(statsTable, 0, atrRowStart + 5, "Win Rate by FVG Size", bgcolor=color.new(color.orange, 50), text_color=color.white, text_size=size.small)
        table.merge_cells(statsTable, 0, atrRowStart + 5, 1, atrRowStart + 5)

        // < 30% ATR
        float wr30 = fvgUnder30 > 0 ? (fvgUnder30Wins / fvgUnder30) * 100 : 0
        color color30 = wr30 >= 50 ? color.green : color.red
        table.cell(statsTable, 0, atrRowStart + 6, "< 30% ATR:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.tiny)
        table.cell(statsTable, 1, atrRowStart + 6, str.tostring(wr30, "#") + "% (" + str.tostring(fvgUnder30) + ")", bgcolor=color.new(color30, 80), text_color=color.white, text_size=size.tiny)

        // 30-60% ATR
        float wr3060 = fvg30to60 > 0 ? (fvg30to60Wins / fvg30to60) * 100 : 0
        color color3060 = wr3060 >= 50 ? color.green : color.red
        table.cell(statsTable, 0, atrRowStart + 7, "30-60% ATR:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.tiny)
        table.cell(statsTable, 1, atrRowStart + 7, str.tostring(wr3060, "#") + "% (" + str.tostring(fvg30to60) + ")", bgcolor=color.new(color3060, 80), text_color=color.white, text_size=size.tiny)

        // 60-100% ATR
        float wr60100 = fvg60to100 > 0 ? (fvg60to100Wins / fvg60to100) * 100 : 0
        color color60100 = wr60100 >= 50 ? color.green : color.red
        table.cell(statsTable, 0, atrRowStart + 8, "60-100% ATR:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.tiny)
        table.cell(statsTable, 1, atrRowStart + 8, str.tostring(wr60100, "#") + "% (" + str.tostring(fvg60to100) + ")", bgcolor=color.new(color60100, 80), text_color=color.white, text_size=size.tiny)

        // > 100% ATR
        float wr100 = fvgOver100 > 0 ? (fvgOver100Wins / fvgOver100) * 100 : 0
        color color100 = wr100 >= 50 ? color.green : color.red
        table.cell(statsTable, 0, atrRowStart + 9, "> 100% ATR:", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.tiny)
        table.cell(statsTable, 1, atrRowStart + 9, str.tostring(wr100, "#") + "% (" + str.tostring(fvgOver100) + ")", bgcolor=color.new(color100, 80), text_color=color.white, text_size=size.tiny)

// Background color for active setup
bgcolor(activeFvgSetup and showBuySignals ? color.new(color.orange, 95) : na, title="Active Buy Setup")
bgcolor(activeBullishFvgSetup and showSellSignals ? color.new(color.blue, 95) : na, title="Active Sell Setup")

// Debug: Plot markers for all FVGs detected
plotshape(isBearishFvg() and showBuySignals, title="Bearish FVG Detected", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.tiny, text="BFVG")
plotshape(isBullishFvg() and showSellSignals, title="Bullish FVG Detected", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.tiny, text="BFVG")

// Plot trend line
plot(showTrendLine ? trendLine : na, title="Trend Line", color=color.new(color.yellow, 0), linewidth=2)

// Alert conditions for creating alerts in TradingView
// Note: In the alert dialog, set the Message field to: {{message}}
alertcondition(buySignalTriggered and showBuySignals, title="Buy Signal", message="BUY Signal triggered - use {{message}} in alert message field")
alertcondition(sellSignalTriggered and showSellSignals, title="Sell Signal", message="SELL Signal triggered - use {{message}} in alert message field")
alertcondition((buySignalTriggered and showBuySignals) or (sellSignalTriggered and showSellSignals), title="Buy or Sell Signal", message="Signal triggered - use {{message}} in alert message field")